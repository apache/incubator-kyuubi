/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.kyuubi

import java.io.{File, FileOutputStream, OutputStream}
import java.nio.charset.Charset
import java.nio.file.{Path, Paths}

import scala.concurrent.duration._

import org.apache.spark.benchmark.Benchmark
import org.apache.spark.kyuubi.benchmark.KyuubiBenchmarkBase
import org.apache.spark.sql.util.CaseInsensitiveStringMap

import org.apache.kyuubi.{KyuubiFunSuite, Utils}
import org.apache.kyuubi.spark.connector.tpcds.{TPCDSPartitionReader, TPCDSSchemaUtils, TPCDSStatisticsUtils, TPCDSTable}

/**
 * Benchmark to measure the performance of generate TPCDSTable.
 *
 * {{{
 *   RUN_BENCHMARK=1 ./build/mvn clean test \
 *   -pl extensions/spark/kyuubi-spark-connector-tpcds -am \
 *   -Dtest=none -DwildcardSuites=org.apache.spark.kyuubi.TPCDSTableGenerateBenchmark
 * }}}
 */
class TPCDSTableGenerateBenchmark extends KyuubiFunSuite with KyuubiBenchmarkBase {

  private val runBenchmark = sys.env.contains("RUN_BENCHMARK")
  private val numRows: Long = 1 * 1000 * 1000
  private val scale = TPCDSStatisticsUtils.SCALES.last
  private val sourcePackage: Path = {
    val modulePath = Utils.getCodeSourceLocation(getClass)
      .split("kyuubi-spark-connector-tpcds")(0)
    Paths.get(
      modulePath,
      "kyuubi-spark-connector-tpcds",
      "src/main/scala",
      "org/apache/kyuubi/spark/connector/tpcds")
  }

  test("benchmark") {
    assume(runBenchmark)
    withHeader {
      val results = numRowsTableBenchmark()
      generateClass(results)
    }
  }

  private def numRowsTableBenchmark(): Array[TPCDSTableGenerateResult] = {
    val benchmark =
      new TPCDSTableBenchmark(
        s"TPCDS table generates $numRows rows benchmark",
        numRows,
        minTime = 30.seconds,
        output = output)
    TPCDSSchemaUtils.BASE_TABLES
      .filter(TPCDSStatisticsUtils.numRows(_, scale) >= numRows)
      .map(_.getName)
      .foreach { table =>
        benchmark.addCase(s"$table benchmark", 3) { _ =>
          generateTable(table, numRows)
        }
      }
    benchmark.run()
    benchmark.getGenerateResults()
  }

  private def generateClass(results: Array[TPCDSTableGenerateResult]): Unit = {
    val classFile = new File(sourcePackage.toFile, "TPCDSSplitUtils.scala")
    val classOutputStream = new FileOutputStream(classFile)
    def write(text: String): Unit = {
      classOutputStream.write(text.getBytes(Charset.forName("UTF-8")))
    }

    val mapBody = results.map { result =>
      val tableName = result.name.split(" ")(0).toUpperCase
      val rowsPerTenSecond = (numRows / (result.avgMs / 10 / 1000)).toLong
      s"    $tableName -> $rowsPerTenSecond"
    }.mkString(",\n")

    write(
      s"""/*
         | * Licensed to the Apache Software Foundation (ASF) under one or more
         | * contributor license agreements.  See the NOTICE file distributed with
         | * this work for additional information regarding copyright ownership.
         | * The ASF licenses this file to You under the Apache License, Version 2.0
         | * (the "License"); you may not use this file except in compliance with
         | * the License.  You may obtain a copy of the License at
         | *
         | *    http://www.apache.org/licenses/LICENSE-2.0
         | *
         | * Unless required by applicable law or agreed to in writing, software
         | * distributed under the License is distributed on an "AS IS" BASIS,
         | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         | * See the License for the specific language governing permissions and
         | * limitations under the License.
         | */
         |package org.apache.kyuubi.spark.connector.tpcds
         |
         |import io.trino.tpcds.Table
         |import io.trino.tpcds.Table._
         |
         |/**
         | * Generated by TPCDSTableGenerateBenchmark
         | */
         |object TPCDSSplitUtils {
         |
         |  def getSplits(table: Table, scale: Int, splitPerTask: Int): Int = {
         |    val numRows = TPCDSStatisticsUtils.numRows(table, scale)
         |    if (TABLE_ROWS_PER_SPLIT.contains(table)) {
         |      (numRows.toDouble / TABLE_ROWS_PER_SPLIT(table) / splitPerTask).ceil.toInt
         |    } else {
         |      1
         |    }
         |  }
         |
         |  private val TABLE_ROWS_PER_SPLIT: Map[Table, Long] = Map(
         |$mapBody)
         |
         |}
         |""".stripMargin)

    classOutputStream.close()
  }

  private def generateTable(tableName: String, rowCount: Long): Unit = {
    val table = new TPCDSTable(tableName, scale, CaseInsensitiveStringMap.empty())
    val reader = new TPCDSPartitionReader(
      tableName,
      scale,
      1,
      1,
      table.schema)
    var count = 0
    while (reader.next() && count < rowCount) {
      count += 1
    }
    assert(count == rowCount)
  }

  private case class TPCDSTableGenerateResult(name: String, avgMs: Double)

  private class TPCDSTableBenchmark(
      name: String,
      valuesPerIteration: Long,
      minNumIters: Int = 2,
      warmupTime: FiniteDuration = 2.seconds,
      minTime: FiniteDuration = 2.seconds,
      outputPerIteration: Boolean = false,
      output: Option[OutputStream] = None) extends Benchmark(
      name,
      valuesPerIteration,
      minNumIters,
      warmupTime,
      minTime,
      outputPerIteration,
      output) {

    private var generateResults: Array[TPCDSTableGenerateResult] = _

    def getGenerateResults(): Array[TPCDSTableGenerateResult] = generateResults

    override def run(): Unit = {
      require(benchmarks.nonEmpty)
      // scalastyle:off
      println("Running benchmark: " + name)

      val results = benchmarks.map { c =>
        println("  Running case: " + c.name)
        measure(valuesPerIteration, c.numIters)(c.fn)
      }
      println

      val firstBest = results.head.bestMs
      // The results are going to be processor specific so it is useful to include that.
      out.println(Benchmark.getJVMOSInfo())
      out.println(Benchmark.getProcessorName())
      val nameLen = Math.max(40, Math.max(name.length, benchmarks.map(_.name.length).max))
      out.printf(
        s"%-${nameLen}s %14s %14s %11s %12s %13s %10s\n",
        name + ":",
        "Best Time(ms)",
        "Avg Time(ms)",
        "Stdev(ms)",
        "Rate(M/s)",
        "Per Row(ns)",
        "Relative")
      out.println("-" * (nameLen + 80))
      generateResults = results.zip(benchmarks).map { case (result, benchmark) =>
        out.printf(
          s"%-${nameLen}s %14s %14s %11s %12s %13s %10s\n",
          benchmark.name,
          "%5.0f" format result.bestMs,
          "%4.0f" format result.avgMs,
          "%5.0f" format result.stdevMs,
          "%10.1f" format result.bestRate,
          "%6.1f" format (1000 / result.bestRate),
          "%3.1fX" format (firstBest / result.bestMs))
        TPCDSTableGenerateResult(benchmark.name, result.avgMs)
      }.toArray
      out.println
      // scalastyle:on
    }
  }
}
